# Практика 3: Оптимизация работы с памятью

## Цели

## Задачи

__Основные задачи__

  1. Научиться измерять и сравнивать время работы/производительность различных
     реализаций одного алгоритма.
  1. Познакомиться с измерением производительности алогритмов, время работы
     которых зависит от данных.
     * Что произойдет, если в предложенном тесте убрать инициализацию
       геренатора случайных чисел фиксированным значеним? Можно ли так
       поступить?
     * Является ли предложенный тест производительности хорошим?
  1. Применить две базовые техники оптимизации:
     * минимизация числа операций
     * кэширование вычислений
  1. Сравнить эффект от применения двух пердложенных оптимизаций
     по-отдельности и совместно.

__Дополнительные задачи__

  - Разобраться с зависимостью времени работы алгоритма от данных. Добавить
    тесты для лучшего и чудшего случая.
  - Выясннить, какой порядок загрузки значений соседних пикселей является
    наиболее эффективным. Объяснить почему.
  - (Домашнее задание). В случае NxN изображния, предложеннная реализация
    алгоритма имеет оценку вычислительной сложности в худшем случае `O(N^3)`.
    Возможна реализация с оценкой `O(N^2)`. Предложить такую реализацию,
    сравнить производительность.

## Общая последовательность действий

  1. Сделать форк [upstream][upstream]-репозитория и клонировать
     [origin][origin]-репозиторий к себе на локальную машину. Собрать проект и
     проверить его работоспособность, запустив тесты и  демо-приложение.
  1. Создать новую ветку в Git для выполнения практического задания.
     Изменения необходимо постоянно фиксировать в истории Git, выкладывая в
     рабочую ветку на GitHub и контролируя успешность тестирования на Travis-CI.
  1. Запустить тесты производительности для функции `GuoHallThinning` и
     сохранить XML файл с результатами. Этот файл в дальнейшем будет использован
     для сравнения производительности до и после оптимизации.
  1. Разобраться с алгоритмом `GuoHallThinning` и оптимизировать его используюя
     следующие приемы:
     * минимизация числа операций, особенно обращений к памяти
     * кэширование вычислений
  1. Убедиться что оптимизированная функция работает быстрее чем оригинальный
     код. При этом результат работы оптимизированная функции должен полностью
     совпадать с результатом исходной версии.

## Детальная инструкция по выполнению работы

  1. Запуск тестов производительности:
     1. Убедитесь, что проект собран в **`Release`** конфигурации!

     1. Тесты производительности находятся в `perf_skeleton.exe` для их
        запуска достаточно запустить это приложение. Тесты производительности
        **не печатают** времена работы функций в консольном выводе:

        ```bash
        $ cd itseez-ws-2016-practice-build/bin
        $ ./perf_skeleton.exe
        ```

     1. Для того, чтобы сохранить результаты измерения производительности
        необходимо передать тестовому фреймворку им файла для записи разельтатов
        текущего запуска:

        ```bash
        $ ./perf_skeleton.exe --gtest_output=xml:before_optimization.xml
        ```

     1. Для просмотра производительности одного эксперимента можно
        использовать скрипт `report.py`, являющийся частью тестового фреймворка:

        ```bash
        $ python 3rdparty/opencv_ptest/misc/report.py before_optimization.xml -c gmean,min,samples
        ```

        ```txt
                 Name of Test          Geometric mean    Min         Number of
                                                                 collected samples
        Thinning::Size_Only::1280x720    831.34 ms    824.14 ms         49
        Thinning::Size_Only::1920x1080   2422.72 ms   2400.85 ms        17
        Thinning::Size_Only::640x480     340.01 ms    336.50 ms         100
        ```

     1. Для сравнения производительности нескольких версий можно использовать скрипт `summary.py`:

        ```bash
        $ python 3rdparty/opencv_ptest/misc/summary.py base.xml optimized.xml
        ```

        ```txt
                 Name of Test             base      optimized  optimized
                                                                   vs
                                                                  base
                                                               (x-factor)
        Thinning::Size_Only::640x480   340.009 ms  143.618 ms     2.37
        Thinning::Size_Only::1280x720  831.337 ms  362.249 ms     2.29
        Thinning::Size_Only::1920x1080 2422.718 ms 1057.336 ms    2.29
        ```

     1. Для ускорения проведения экспериментов можно исключить не относящиеся
        к оптимизируемой функции тесты используя фильтр:

        ```bash
        $ ./perf_skeleton.exe --gtest_output=xml:optimized.xml --gtest_filter=*Thinning*
        ```

  1. Применение "первого" приема оптимизации - избегание ненужных обращений к
     памяти и вычислений: обратите внимание на следующее свойство алгоритма -
     если какой либо из пикселей обратился в ноль, то он уже ни когда не станет
     не нулевым. Значит, в функции GuoHallIteration для пикселей с нулевым
     значением можно не проверять соседей.

  1. Применение "второго" приёма оптимизации - кэширование вычислений:

     1. Тот факт, что функция работает с бинарным изображением позволяет
        взаимнооднозначно закодировать всех соседей пикселя используя всего 1
        байт. Например:

        ```txt
        1 0 1
        1 . 0
        1 0 1
        ```

        Можно представить в бинарном виде как `10110101` (181 в десятичной
        записи). Таким образом, всего существует 256 вариантов для любой точки.

        Применительно к данной задаче, кодирование может выглядеть следующим образом:

        ```cpp
        // pixel neighbourhood
        // p9 p2 p3
        // p8 p1 p4
        // p7 p6 p5

        // encode
        code = p2 * 1 +
               p3 * 2 +
               p4 * 4 +
               p5 * 8 +
               p6 * 16 +
               p7 * 32 +
               p8 * 64 +
               p9 * 128;

        // decode
        p2 = code & 1;
        p3 = code & 2;
        p4 = code & 4;
        p5 = code & 8;
        p6 = code & 16;
        p7 = code & 32;
        p8 = code & 64;
        p9 = code & 128;

        ```

     1. Логику обработки одной точки в функции GuoHallIteration можно заменить
        на логику кодирования и поиска в заранее подготовленной таблице.

        Tips:

        * Логика преобразования зависит от параметра `iter`, так что необходимо подготовить две таблицы.
        * Время построения таблиц пренебрежимо мало в сравнинии с основным
          алгоритмом. Можно пересоздавать таблицы при каждом вызове функции.
        * Порядок загрузки значений соседних пикселей может незначительно
          влиять на скорость выполнения кода.
        * Не стоит тратить время на оптимизацию вычислений в функции
          `GuoHallIteration` - это не перспективное направление.
        * Функцию можно переписать так, чтобы избежать копирований, операций
          применения маски и конверсии значений 255 в 1 и обратно, но затраты
          на все эти операции меньше, чем эффект от оптимизаций предложенных в
          описании выше.

<!-- LINKS -->
