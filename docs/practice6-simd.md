# Практика 6: Использование векторных инструкций

[![Feedback](feedback.png)][feedback_day6]

## Цели

__Цель данной работы__ — освоить такую технику, как векторизация вычислений за
счет переписывания кода с использованием инструкций из расширенного набора
команд SSE2/SSSE3, реализующими `SIMD` идеому.


## Задачи

  1. Создать векторную реализацию функции `ConvertColor_BGR2GRAY_BT709_fpt`.
  1. Оценить полученные ускорения.

## Общая последовательность действий

Поскольку это очередной шаг в оптимизации, его необходимо будет выполнить по уже
знакомому нам алгоритму: собираем данные о производительности базовой версии,
осуществляем оптимизацию, анализируем полученное ускорение.

  1. Перед началом оптимизации необходимо осуществить знакомые нам
     предварительные действия:

     - Получить актуальную версию кодов из центрального репозитория (см.
       [инструкции][git-update]). Затем нужно собрать проект и проверить его
       работоспособность, запустив тесты и демо-приложение.

     - Далее нужно создать новую ветку в Git для выполнения практического
       задания. Изменения необходимо постоянно фиксировать в истории Git,
       выкладывая в рабочую ветку на GitHub и контролируя успешность
       тестирования на Travis-CI.

     - Запустить тесты производительности функции `ConvertColor_BGR2GRAY_BT709`
       и сохранить XML-файл с результатами. Этот файл в дальнейшем будет
       использован для сравнения производительности до и после оптимизации.

  1. Разобраться с алгоритмом `ConvertColor_BGR2GRAY_BT709` и оптимизировать его
     используя инструкции из наборов комманд SSE2/SSSE3. Для этого используйте
     заготовку `ConvertColor_BGR2GRAY_BT709_simd`.

  1. В конце, как обычно, стоит убедиться, что оптимизированная функция работает
     быстрее, чем оригинальный код. Проанализируйте ускорения, сравнивая отчеты
     о производительности до и после оптимизации.

## Детальная инструкция по выполнению работы

  1. Следующий набор SSE операций (интринсиков) достаточен для выполнения
     данного задания ([подробное описание интринсиков][intrin_guide]):

     - `_mm_add_epi16`
     - `_mm_add_epi32`
     - `_mm_loadu_si128`
     - `_mm_mullo_epi16`
     - `_mm_mullo_epi32`
     - `_mm_or_si128`
     - `_mm_packus_epi16`
     - `_mm_packus_epi32`
     - `_mm_set1_epi16`
     - `_mm_setzero_si128`
     - `_mm_shuffle_epi8`
     - `_mm_srli_epi16`
     - `_mm_srli_epi16`
     - `_mm_storeu_si128`
     - `_mm_unpackhi_epi16`
     - `_mm_unpackhi_epi8`
     - `_mm_unpacklo_epi16`
     - `_mm_unpacklo_epi8`

     Например, `_mm_set1_epi16` позволяет одной инструкцией установить восемь
     16-битных элементов вектора в одно значение, а `_mm_setzero_si128` — это
     эффективный способ обнуления вектора:

     ```cpp
     __m128i green_coeff = _mm_set1_epi16(183);
     __m128i zero = _mm_setzero_si128();
     ```

  1. Для удовлетворения заданных критериев точности достаточно воспользоваться
     числами с фиксированной точкой использующими 8 бит для дробной части:
     `Q7.8`.

  1. Индексы для векторной распаковки `BGR` формата изображения, а также пример
     распаковки для `R` канала являются частью заготовки
     `ConvertColor_BGR2GRAY_BT709_simd`.

<!-- LINKS -->

[feedback_day6]: https://docs.google.com/forms/d/1iNNPX4Z_2aoWVOfh_ZEUVFuy_AJ4V0n5wZ3p7NWPZO4/viewform
[git-update]:    https://github.com/itseez-academy/itseez-ws-2016-practice/blob/master/docs/practice2-profiling-and-benchmarking.md#Получение-актуальной-версии-исходных-файлов
[intrin_guide]:  https://software.intel.com/sites/landingpage/IntrinsicsGuide/
