# Практика 4: Компилятор и оптимизация

## Цели

__Цель данной работы__ - познакомиться с примеров кода, незначительные
изменения которого оказывают существенное влияние на производительность. В
частности, увидеть на практическом примере, какие оптимизации помогают
компилятору генерировать более эффективный код, а какие - нет.


## Задачи

__Основные задачи__

  1.

__Дополнительные задачи__

  -

## Общая последовательность действий

  1. Сделать форк [upstream][upstream]-репозитория и клонировать
     [origin][origin]-репозиторий к себе на локальную машину. Собрать проект и
     проверить его работоспособность, запустив тесты и  демо-приложение.
  1. Создать новую ветку в Git для выполнения практического задания.
     Изменения необходимо постоянно фиксировать в истории Git, выкладывая в
     рабочую ветку на GitHub и контролируя успешность тестирования на Travis-CI.
  1. Запустить тесты производительности для функции `ImageResize` и
     сохранить XML файл с результатами. Этот файл в дальнейшем будет использован
     для сравнения производительности до и после оптимизации.
  1. Разобраться с алгоритмом `ImageResize` и оптимизировать его используюя
     следующие приемы:
     * удаление недостижимого кода;
     * вынос операций не зависящих от итерации цикла за пределы цикла;
     * изменение типов данных: `uchar` или `int`, `int` или `uint`, `float` или `double`  и т.д.;
     * "небезопасное" переупорядочивание вычислений с плавающей запятой;
     * использование знаний о возможных значениях аргументов для упрощения вычислений;
  1. Убедиться что оптимизированная функция работает быстрее чем оригинальный
     код.

## Детальная инструкция по выполнению работы

  1. Подробные инструкции по использованию `git` и измерению производительности
     могут быть найдены в описаниях предыдущих практических заданий.
  1. Рассматриваемая в данном практическом задании функция `ImageResize`
     реализует метод изменения размера изображения с использованием билинейной
     интерполяции. Изображение полученное с использованием оптимизированной
     версии должно отличаться от изображения полученнного с использованием
     исходной реализации не более чем на 1.
  1. Перечисленные ниже особенности могут быть полезны для оптимизации `ImageResize`:
     * Формулы вычисления координат могут быть преобразованы следующим образом:

       ```cpp
       const float x = (((float)col) + .5f) * sz_src.width  / sz.width  - .5f;
       ```

       ```cpp
       const float x = col * xscale + x0;
       ```
       где `xscale` и `x0` - это floating-point константы не зависящие от текущих
       координат.
     * Для неотрицательных значений `x` С++ выражения `(int)floor(x)` и
       `(int)(x)` приводят к одинаковому результату. Однако это не верно для
       `x < 0` и `x > (1<<31)`.
     * Билинейная интерполяция не выводит значения за пределы диапазона
       значений исходных данных. Т.е. если исходные данные принадлежат
       диапазону `0 <= value <= 255` то и результат интерполяции принадлежит
       диапазону `[0, 255]` для любых возможных комбинаций значений исходных
       данных.

     * При уменьшении изображения вычисленные координаты пикселей исходного
       изображения всегда находятся в пределах изображения. Т.е. применительно к
       исходному коду:

        ```cpp
       0 <= ix && ix < src.cols - 1
       0 <= iy && iy < src.rows - 1
       ```

<!-- LINKS -->
